class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        //这题还是一样的想法，干两件事情：找左边界和右边界
        //牢记区间的一致性[左边界+1,右边界-1]之间的数字应该是target
        
  
        int left_flag=getLeftBorder(nums,target),right_flag=getRightBorder(nums,target);
        //情况一：target小于列表最小值大于列表最大值
        if (left_flag==-2 || right_flag==-2)
          return {-1,-1};
        //情况二：正常情况
        else if (right_flag-left_flag>1)
          return {left_flag+1,right_flag-1};
        //情况三：target 在列表最小值和最大值范围内但不在列表中，换句话说左右边界中间没有target
        else
          return {-1,-1};

    }
private:
    /*顺口溜总结一下就是：找左边界 右边(right)跟着跑 左边界=右边
                        找右边界 左边(left)跟着跑  右边界=左边
      两个函数相互对称*/

                    
    int getLeftBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;//明确left和right的目的是在确定左边界的位置
        int LeftBorder=-2;
        int mid=(left+right)>>1;
        while (left<=right)
        {
            if (nums[mid]>=target) //这时候我能确定我要找的左边界一定在[left,mid-1]之间
            {
                right=mid-1;
                LeftBorder=right;
            }
            else
            {
                //nums[mid]<target，这个时候我就不能确定找的左边界在哪里了
                left=mid+1;
            }
            mid=(left+right)>>1;
        }
        return LeftBorder;
    }
    //实际上上下两个函数是对称过程
     int getRightBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;//明确left和right的目的是在确定左边界的位置
        int RightBorder=-2;
        int mid=(left+right)>>1;
        while (left<=right)
        {
            if (nums[mid]<=target) //这时候我能确定我要找的右边界一定在[mid+1,right]之间
            {
                left=mid+1;
                RightBorder=left;
            }
            else
            {
                //nums[mid]<target，这个时候我就不能确定找的左边界在哪里了
                right=mid-1;
            }
            mid=(left+right)>>1;
        }
        return RightBorder;
    }

};